<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Color Consultation Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 { font-size: 2em; margin-bottom: 10px; }
        .header p { opacity: 0.9; font-size: 1.1em; }

        .content { padding: 40px; }

        .step { display: none; }
        .step.active { display: block; animation: fadeIn 0.5s; }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Upload Area */
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-area:hover { border-color: #764ba2; background: #f0f2ff; }
        .upload-area.dragover { border-color: #764ba2; background: #e8ebff; transform: scale(1.02); }
        .upload-icon { font-size: 4em; margin-bottom: 15px; }
        .upload-area h3 { color: #333; margin-bottom: 10px; }
        .upload-area p { color: #666; }
        #fileInput { display: none; }

        /* Preview */
        .preview-container {
            margin-top: 30px;
            text-align: center;
        }

        .preview-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .change-photo-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .change-photo-btn:hover { background: rgba(0,0,0,0.9); }

        /* Wall Selection */
        .wall-selection-container { text-align: center; }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin: 20px 0;
        }

        .canvas-wrapper canvas {
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            max-width: 100%;
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #interactionCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .loading-overlay {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .info-box {
            background: linear-gradient(135deg, #e8f4ff 0%, #f0f4ff 100%);
            border: 1px solid #667eea;
            border-radius: 12px;
            padding: 20px;
            margin: 20px auto;
            max-width: 600px;
            text-align: left;
        }

        .info-box h4 { color: #667eea; margin-bottom: 12px; }
        .info-box p { color: #555; line-height: 1.6; margin-bottom: 8px; }

        .status-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            margin: 10px 0;
        }

        .status-badge.success { background: #e8f5e9; color: #2e7d32; }
        .status-badge.info { background: #e3f2fd; color: #1565c0; }

        /* Buttons */
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(102,126,234,0.4); }
        .btn-primary:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .btn-secondary { background: #e0e0e0; color: #333; }
        .btn-secondary:hover { background: #d0d0d0; }

        .btn-outline {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-outline:hover { background: #f0f2ff; }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        /* Chat / Questions */
        .chat-container {
            max-height: 450px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .message {
            margin-bottom: 15px;
            padding: 12px 18px;
            border-radius: 15px;
            max-width: 85%;
        }

        .message.ai { background: #667eea; color: white; margin-right: auto; }
        .message.user { background: #e8ebff; color: #333; margin-left: auto; }

        .input-group { margin-bottom: 20px; }

        .input-group select,
        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
        }

        .input-group select:focus,
        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-bottom: 25px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s;
        }

        /* Results */
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .comparison-image { text-align: center; }

        .comparison-image img {
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .comparison-image h4 { margin-top: 10px; color: #333; }

        .color-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }

        .color-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
            cursor: pointer;
            border: 3px solid transparent;
        }

        .color-card:hover { transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,0.15); }
        .color-card.selected { border-color: #667eea; }
        .color-card.loading { opacity: 0.7; pointer-events: none; }

        .color-swatch { height: 100px; position: relative; }

        .color-swatch .generating {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        .color-info { padding: 15px 20px; }
        .color-name { font-size: 1.05em; font-weight: 600; color: #333; margin-bottom: 5px; }
        .color-code { color: #666; font-size: 0.9em; margin-bottom: 8px; }
        .color-description { color: #555; font-size: 0.9em; line-height: 1.5; }

        .preview-status {
            font-size: 0.85em;
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 12px;
            display: inline-block;
        }

        .preview-status.ready { background: #e8f5e9; color: #2e7d32; }
        .preview-status.generating { background: #fff3e0; color: #e65100; }

        /* Responsive */
        @media (max-width: 768px) {
            .comparison-container { grid-template-columns: 1fr; }
            .content { padding: 20px; }
            .header { padding: 20px; }
            .header h1 { font-size: 1.5em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® AI Color Consultation</h1>
            <p>Upload your room photo and get personalized Sherwin Williams recommendations with realistic previews</p>
        </div>

        <div class="content">
            <!-- Step 1: Upload -->
            <div class="step active" id="step1">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì∏</div>
                    <h3>Upload Your Room Photo</h3>
                    <p>Drag and drop or click to select an image</p>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                <div class="preview-container" id="previewContainer" style="display: none;">
                    <div class="preview-wrapper">
                        <img id="uploadedImage" class="preview-image" alt="Room preview">
                        <button class="change-photo-btn" onclick="replacePhoto()">üîÑ Change Photo</button>
                    </div>
                    <br><br>
                    <button class="btn btn-primary" onclick="goToWallSelection()">Continue ‚Üí</button>
                </div>
            </div>

            <!-- Step 2: Wall Selection -->
            <div class="step" id="step2">
                <h2 style="text-align: center; margin-bottom: 15px;">Select Walls to Paint</h2>
                
                <div class="wall-selection-container">
                    <div class="info-box">
                        <h4>‚ú® AI-Powered Wall Detection</h4>
                        <p>Our AI will automatically detect all the walls and surfaces in your room. Just click on the areas you want to paint to select or deselect them.</p>
                    </div>
                    
                    <div id="selectionStatus" class="status-badge info">Click "Detect Walls" to start</div>
                    
                    <div class="canvas-wrapper" id="canvasWrapper">
                        <canvas id="baseCanvas"></canvas>
                        <canvas id="overlayCanvas"></canvas>
                        <canvas id="interactionCanvas"></canvas>
                        <div id="loadingOverlay" class="loading-overlay" style="display: none;">
                            <div class="spinner"></div>
                            <p id="loadingText">AI is detecting walls...</p>
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button class="btn btn-primary" id="detectBtn" onclick="detectWalls()">‚ú® Detect Walls</button>
                        <button class="btn btn-outline" onclick="selectAll()">Select All</button>
                        <button class="btn btn-outline" onclick="clearSelection()">Clear</button>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="goBack(1)">‚Üê Back</button>
                    <button class="btn btn-primary" id="continueToQuestionsBtn" onclick="goToQuestions()">Continue to Questions ‚Üí</button>
                </div>
            </div>

            <!-- Step 3: Questions -->
            <div class="step" id="step3">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="chat-container" id="chatContainer"></div>
                <div id="inputArea"></div>
            </div>

            <!-- Step 4: Results -->
            <div class="step" id="step4">
                <h2 style="text-align: center; margin-bottom: 25px;">Your Personalized Color Recommendations</h2>
                
                <div class="comparison-container">
                    <div class="comparison-image">
                        <h4>Original</h4>
                        <img id="originalImage" src="" alt="Original">
                    </div>
                    <div class="comparison-image">
                        <h4>With Selected Color</h4>
                        <img id="previewImage" src="" alt="Preview">
                        <div id="previewLoading" style="display: none; margin-top: 10px;">
                            <div class="spinner" style="width: 30px; height: 30px; margin: 0 auto;"></div>
                            <p style="font-size: 0.9em; color: #666;">Generating realistic preview...</p>
                        </div>
                    </div>
                </div>
                
                <h3 style="text-align: center; margin-bottom: 15px;">Click a color to see the AI preview:</h3>
                <div class="color-results" id="colorResults"></div>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn btn-secondary" onclick="location.reload()">Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ STATE ============
        let imageBase64 = null;
        let baseCanvas, overlayCanvas, interactionCanvas;
        let baseCtx, overlayCtx, interactionCtx;
        let canvasWidth, canvasHeight;
        let segments = [];
        let currentQuestion = 0;
        let answers = {};
        let recommendedColors = [];
        let maskDataUrl = null;

        const questions = [
            { id: 'surfaces_to_paint', question: "What are you painting?", type: 'select',
              options: ['All walls', 'Walls and ceiling', 'Walls and trim', 'Everything', 'Accent wall only'] },
            { id: 'room_type', question: "What type of room is this?", type: 'select',
              options: ['Living Room', 'Bedroom', 'Kitchen', 'Bathroom', 'Office', 'Dining Room', 'Hallway', 'Other'] },
            { id: 'lighting', question: "How much natural light does this room get?", type: 'select',
              options: ['Lots of natural light', 'Moderate light', 'Limited light', 'Very little/none'] },
            { id: 'light_bulbs', question: "What type of light bulbs do you use?", type: 'select',
              options: ['Warm white (yellowish)', 'Cool white (bluish)', 'Daylight (neutral)', 'Mixed/Not sure'] },
            { id: 'style', question: "What style are you going for?", type: 'select',
              options: ['Modern/Contemporary', 'Traditional', 'Minimalist', 'Farmhouse/Rustic', 'Bohemian', 'Industrial', 'Coastal', 'Transitional'] },
            { id: 'mood', question: "What mood do you want to create?", type: 'select',
              options: ['Calm & relaxing', 'Energetic & vibrant', 'Warm & cozy', 'Cool & refreshing', 'Sophisticated', 'Bright & cheerful'] },
            { id: 'existing_colors', question: "What colors are your furniture and decor?", type: 'text',
              placeholder: 'e.g., gray sofa, wood floors, white curtains' },
            { id: 'avoid_colors', question: "Any colors to avoid?", type: 'text', placeholder: 'e.g., no pink or orange' },
            { id: 'preference', question: "Do you prefer warm, cool, or neutral tones?", type: 'select',
              options: ['Warm (reds, oranges, yellows)', 'Cool (blues, greens, purples)', 'Neutral (grays, beiges, whites)', 'No preference'] },
            { id: 'additional_info', question: "Anything else we should know?", type: 'textarea', placeholder: 'Optional - any other preferences...' }
        ];

        // ============ UPLOAD ============
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        uploadArea.addEventListener('dragover', e => { e.preventDefault(); uploadArea.classList.add('dragover'); });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', e => { e.preventDefault(); uploadArea.classList.remove('dragover'); handleFile(e.dataTransfer.files[0]); });
        fileInput.addEventListener('change', e => { handleFile(e.target.files[0]); fileInput.value = ''; });

        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    let w = img.width, h = img.height;
                    const maxSize = 1024;
                    if (w > maxSize || h > maxSize) {
                        if (w > h) { h = Math.round(h * maxSize / w); w = maxSize; }
                        else { w = Math.round(w * maxSize / h); h = maxSize; }
                    }
                    const canvas = document.createElement('canvas');
                    canvas.width = w; canvas.height = h;
                    canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                    imageBase64 = canvas.toDataURL('image/jpeg', 0.9);
                    document.getElementById('uploadedImage').src = imageBase64;
                    uploadArea.style.display = 'none';
                    document.getElementById('previewContainer').style.display = 'block';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function replacePhoto() {
            imageBase64 = null;
            segments = [];
            document.getElementById('previewContainer').style.display = 'none';
            uploadArea.style.display = 'block';
        }

        // ============ NAVIGATION ============
        function goToWallSelection() {
            showStep(2);
            initCanvases();
        }

        function goBack(step) {
            showStep(step);
        }

        function goToQuestions() {
            // Create mask from selection
            createMaskFromSelection();
            showStep(3);
            currentQuestion = 0;
            askQuestion();
        }

        function showStep(num) {
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
            document.getElementById('step' + num).classList.add('active');
        }

        // ============ WALL SELECTION ============
        function initCanvases() {
            baseCanvas = document.getElementById('baseCanvas');
            overlayCanvas = document.getElementById('overlayCanvas');
            interactionCanvas = document.getElementById('interactionCanvas');
            baseCtx = baseCanvas.getContext('2d');
            overlayCtx = overlayCanvas.getContext('2d');
            interactionCtx = interactionCanvas.getContext('2d');

            const img = new Image();
            img.onload = () => {
                let w = img.width, h = img.height;
                const maxW = Math.min(700, window.innerWidth - 80);
                if (w > maxW) { h = Math.round(h * maxW / w); w = maxW; }
                
                canvasWidth = w; canvasHeight = h;
                [baseCanvas, overlayCanvas, interactionCanvas].forEach(c => {
                    c.width = w; c.height = h;
                });
                
                baseCtx.drawImage(img, 0, 0, w, h);
            };
            img.src = imageBase64;

            interactionCanvas.addEventListener('click', handleCanvasClick);
        }

        async function detectWalls() {
            const btn = document.getElementById('detectBtn');
            const loading = document.getElementById('loadingOverlay');
            const status = document.getElementById('selectionStatus');
            
            btn.disabled = true;
            loading.style.display = 'flex';
            document.getElementById('loadingText').textContent = 'AI is detecting walls and surfaces...';

            try {
                const response = await fetch('/api/segment-image', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageBase64 })
                });
                
                const data = await response.json();
                
                if (data.segments && data.segments.length > 0) {
                    await loadSegments(data.segments);
                    status.className = 'status-badge success';
                    status.textContent = `‚úì Found ${segments.length} surfaces - click to select/deselect`;
                } else {
                    throw new Error('No segments found');
                }
            } catch (error) {
                console.log('Using fallback detection:', error);
                document.getElementById('loadingText').textContent = 'Using smart detection...';
                await fallbackDetection();
                status.className = 'status-badge success';
                status.textContent = `‚úì Found ${segments.length} surfaces - click to select/deselect`;
            } finally {
                btn.disabled = false;
                loading.style.display = 'none';
            }
        }

        async function loadSegments(segmentData) {
            segments = [];
            
            for (const seg of segmentData) {
                try {
                    const maskImg = new Image();
                    maskImg.crossOrigin = 'anonymous';
                    
                    await new Promise((resolve, reject) => {
                        maskImg.onload = resolve;
                        maskImg.onerror = reject;
                        setTimeout(reject, 5000);
                        maskImg.src = seg.mask;
                    });
                    
                    const maskCanvas = document.createElement('canvas');
                    maskCanvas.width = canvasWidth;
                    maskCanvas.height = canvasHeight;
                    const maskCtx = maskCanvas.getContext('2d');
                    maskCtx.drawImage(maskImg, 0, 0, canvasWidth, canvasHeight);
                    
                    const maskData = maskCtx.getImageData(0, 0, canvasWidth, canvasHeight);
                    
                    // Count pixels
                    let count = 0;
                    for (let i = 0; i < maskData.data.length; i += 4) {
                        if (maskData.data[i] > 128 || maskData.data[i + 3] > 128) count++;
                    }
                    
                    const coverage = count / (canvasWidth * canvasHeight);
                    if (coverage > 0.02 && coverage < 0.8) {
                        segments.push({
                            mask: maskData,
                            selected: coverage > 0.08,
                            coverage
                        });
                    }
                } catch (e) {
                    console.log('Segment load error:', e);
                }
            }
            
            if (segments.length === 0) {
                await fallbackDetection();
            } else {
                renderOverlay();
            }
        }

        async function fallbackDetection() {
            const imgData = baseCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            const visited = new Uint8Array(canvasWidth * canvasHeight);
            segments = [];
            
            // Grid-based flood fill
            for (let gy = 20; gy < canvasHeight - 20; gy += 25) {
                for (let gx = 20; gx < canvasWidth - 20; gx += 25) {
                    const idx = gy * canvasWidth + gx;
                    if (visited[idx]) continue;
                    
                    const region = floodFill(imgData, gx, gy, visited, 22);
                    const coverage = region.length / (canvasWidth * canvasHeight);
                    
                    if (coverage > 0.03 && coverage < 0.7) {
                        const maskData = overlayCtx.createImageData(canvasWidth, canvasHeight);
                        region.forEach(i => {
                            maskData.data[i * 4 + 3] = 255;
                        });
                        segments.push({ mask: maskData, selected: coverage > 0.1, coverage });
                    }
                }
            }
            
            // Sort by size
            segments.sort((a, b) => b.coverage - a.coverage);
            segments = segments.slice(0, 8);
            
            renderOverlay();
        }

        function floodFill(imgData, startX, startY, visited, tolerance) {
            const pixels = [];
            const stack = [[startX, startY]];
            const si = (startY * canvasWidth + startX) * 4;
            const sr = imgData.data[si], sg = imgData.data[si+1], sb = imgData.data[si+2];
            
            while (stack.length && pixels.length < 100000) {
                const [x, y] = stack.pop();
                if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) continue;
                
                const idx = y * canvasWidth + x;
                if (visited[idx]) continue;
                
                const i = idx * 4;
                const diff = Math.abs(imgData.data[i]-sr) + Math.abs(imgData.data[i+1]-sg) + Math.abs(imgData.data[i+2]-sb);
                if (diff > tolerance * 3) continue;
                
                visited[idx] = 1;
                pixels.push(idx);
                stack.push([x+1,y], [x-1,y], [x,y+1], [x,y-1]);
            }
            return pixels;
        }

        function renderOverlay() {
            overlayCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            segments.forEach(seg => {
                if (!seg.selected) return;
                
                const overlay = overlayCtx.createImageData(canvasWidth, canvasHeight);
                for (let i = 0; i < seg.mask.data.length; i += 4) {
                    if (seg.mask.data[i] > 128 || seg.mask.data[i + 3] > 128) {
                        overlay.data[i] = 102;
                        overlay.data[i + 1] = 126;
                        overlay.data[i + 2] = 234;
                        overlay.data[i + 3] = 120;
                    }
                }
                
                const temp = document.createElement('canvas');
                temp.width = canvasWidth; temp.height = canvasHeight;
                temp.getContext('2d').putImageData(overlay, 0, 0);
                overlayCtx.drawImage(temp, 0, 0);
            });
        }

        function handleCanvasClick(e) {
            if (segments.length === 0) return;
            
            const rect = interactionCanvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) * (canvasWidth / rect.width));
            const y = Math.floor((e.clientY - rect.top) * (canvasHeight / rect.height));
            const idx = (y * canvasWidth + x) * 4;
            
            for (let i = segments.length - 1; i >= 0; i--) {
                const m = segments[i].mask.data;
                if (m[idx] > 128 || m[idx + 3] > 128) {
                    segments[i].selected = !segments[i].selected;
                    renderOverlay();
                    return;
                }
            }
        }

        function selectAll() {
            segments.forEach(s => s.selected = true);
            renderOverlay();
        }

        function clearSelection() {
            segments.forEach(s => s.selected = false);
            renderOverlay();
        }

        function createMaskFromSelection() {
            const maskCanvas = document.createElement('canvas');
            maskCanvas.width = canvasWidth;
            maskCanvas.height = canvasHeight;
            const maskCtx = maskCanvas.getContext('2d');
            
            // White background (unmasked)
            maskCtx.fillStyle = 'black';
            maskCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // White for selected areas (masked)
            segments.forEach(seg => {
                if (!seg.selected) return;
                for (let y = 0; y < canvasHeight; y++) {
                    for (let x = 0; x < canvasWidth; x++) {
                        const i = (y * canvasWidth + x) * 4;
                        if (seg.mask.data[i] > 128 || seg.mask.data[i + 3] > 128) {
                            maskCtx.fillStyle = 'white';
                            maskCtx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            });
            
            maskDataUrl = maskCanvas.toDataURL('image/png');
        }

        // ============ QUESTIONS ============
        function askQuestion() {
            const q = questions[currentQuestion];
            const chat = document.getElementById('chatContainer');
            const input = document.getElementById('inputArea');
            
            document.getElementById('progressFill').style.width = ((currentQuestion + 1) / questions.length * 100) + '%';
            
            const msg = document.createElement('div');
            msg.className = 'message ai';
            msg.textContent = q.question;
            chat.appendChild(msg);
            
            let html = '<div class="input-group">';
            if (q.type === 'select') {
                html += `<select id="answer"><option value="">Select...</option>${q.options.map(o => `<option value="${o}">${o}</option>`).join('')}</select>`;
            } else if (q.type === 'textarea') {
                html += `<textarea id="answer" rows="3" placeholder="${q.placeholder || ''}"></textarea>`;
            } else {
                html += `<input type="text" id="answer" placeholder="${q.placeholder || ''}">`;
            }
            html += '</div><button class="btn btn-primary" onclick="submitAnswer()">Next ‚Üí</button>';
            input.innerHTML = html;
            
            chat.scrollTop = chat.scrollHeight;
        }

        function submitAnswer() {
            const answer = document.getElementById('answer').value.trim();
            if (!answer && currentQuestion < questions.length - 1) {
                alert('Please answer before continuing');
                return;
            }
            
            answers[questions[currentQuestion].id] = answer;
            
            if (answer) {
                const msg = document.createElement('div');
                msg.className = 'message user';
                msg.textContent = answer;
                document.getElementById('chatContainer').appendChild(msg);
            }
            
            currentQuestion++;
            if (currentQuestion < questions.length) {
                setTimeout(askQuestion, 250);
            } else {
                getRecommendations();
            }
        }

        // ============ RECOMMENDATIONS & PREVIEW ============
        async function getRecommendations() {
            document.getElementById('inputArea').innerHTML = `
                <div style="text-align: center; padding: 30px;">
                    <div class="spinner"></div>
                    <p>Getting your personalized color recommendations...</p>
                </div>
            `;

            try {
                const response = await fetch('/api/generate-colors', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ answers })
                });
                
                const data = await response.json();
                if (data.error) throw new Error(data.error);
                
                recommendedColors = data.colors;
                showResults();
                
            } catch (error) {
                document.getElementById('inputArea').innerHTML = `
                    <div style="text-align: center; color: #c62828; padding: 20px;">
                        <p><strong>Error:</strong> ${error.message}</p>
                        <button class="btn btn-primary" onclick="getRecommendations()">Retry</button>
                    </div>
                `;
            }
        }

        function showResults() {
            showStep(4);
            
            document.getElementById('originalImage').src = imageBase64;
            document.getElementById('previewImage').src = imageBase64;
            
            const container = document.getElementById('colorResults');
            container.innerHTML = recommendedColors.map((color, i) => `
                <div class="color-card" id="card-${i}" onclick="selectAndPreview(${i})">
                    <div class="color-swatch" style="background: ${color.hex}">
                        <span class="generating" id="gen-${i}" style="display: none;">Generating...</span>
                    </div>
                    <div class="color-info">
                        <div class="color-name">${color.name}</div>
                        <div class="color-code">${color.hex}</div>
                        <div class="color-description">${color.description}</div>
                        <div class="preview-status generating" id="status-${i}">Click to generate preview</div>
                    </div>
                </div>
            `).join('');
        }

        async function selectAndPreview(index) {
            const color = recommendedColors[index];
            
            // Update selection UI
            document.querySelectorAll('.color-card').forEach((c, i) => {
                c.classList.toggle('selected', i === index);
            });
            
            // If already has preview, just show it
            if (color.previewUrl) {
                document.getElementById('previewImage').src = color.previewUrl;
                return;
            }
            
            // Show loading states
            const card = document.getElementById(`card-${index}`);
            const genLabel = document.getElementById(`gen-${index}`);
            const status = document.getElementById(`status-${index}`);
            const previewLoading = document.getElementById('previewLoading');
            
            card.classList.add('loading');
            genLabel.style.display = 'block';
            status.textContent = 'Generating AI preview...';
            status.className = 'preview-status generating';
            previewLoading.style.display = 'block';
            
            try {
                const response = await fetch('/api/inpaint-walls', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image: imageBase64,
                        mask: maskDataUrl,
                        colorName: color.name,
                        colorHex: color.hex
                    })
                });
                
                const data = await response.json();
                
                if (data.imageUrl) {
                    color.previewUrl = data.imageUrl;
                    document.getElementById('previewImage').src = data.imageUrl;
                    status.textContent = '‚úì Preview ready';
                    status.className = 'preview-status ready';
                } else {
                    throw new Error(data.error || 'Failed to generate');
                }
            } catch (error) {
                console.error('Preview error:', error);
                // Fallback to simple color overlay
                color.previewUrl = createSimplePreview(color.hex);
                document.getElementById('previewImage').src = color.previewUrl;
                status.textContent = '‚úì Preview ready (basic)';
                status.className = 'preview-status ready';
            } finally {
                card.classList.remove('loading');
                genLabel.style.display = 'none';
                previewLoading.style.display = 'none';
            }
        }

        function createSimplePreview(hexColor) {
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');
            
            // Draw base image
            const img = new Image();
            img.src = imageBase64;
            ctx.drawImage(baseCanvas, 0, 0);
            
            // Get pixels
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            const pixels = imageData.data;
            
            // Parse color
            const hex = hexColor.replace('#', '');
            const tr = parseInt(hex.substr(0,2), 16);
            const tg = parseInt(hex.substr(2,2), 16);
            const tb = parseInt(hex.substr(4,2), 16);
            
            // Apply to masked areas
            segments.forEach(seg => {
                if (!seg.selected) return;
                for (let i = 0; i < pixels.length; i += 4) {
                    if (seg.mask.data[i] > 128 || seg.mask.data[i + 3] > 128) {
                        const lum = (0.299 * pixels[i] + 0.587 * pixels[i+1] + 0.114 * pixels[i+2]) / 255;
                        pixels[i] = Math.round(tr * (0.3 + lum * 0.7));
                        pixels[i+1] = Math.round(tg * (0.3 + lum * 0.7));
                        pixels[i+2] = Math.round(tb * (0.3 + lum * 0.7));
                    }
                }
            });
            
            ctx.putImageData(imageData, 0, 0);
            return canvas.toDataURL('image/jpeg', 0.9);
        }
    </script>
</body>
</html>
