<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Color Consultation Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .step {
            display: none;
        }

        .step.active {
            display: block;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f0f2ff;
        }

        .upload-area.dragover {
            border-color: #764ba2;
            background: #e8ebff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            color: #667eea;
            margin-bottom: 15px;
        }

        .upload-area h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .upload-area p {
            color: #666;
        }

        #fileInput {
            display: none;
        }

        .preview-container {
            margin-top: 30px;
            text-align: center;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .preview-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            display: block;
            margin: 0 auto;
        }

        .image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
            cursor: pointer;
        }

        .preview-wrapper:hover .image-overlay {
            opacity: 1;
        }

        .overlay-content {
            text-align: center;
            color: white;
        }

        .overlay-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .overlay-text {
            font-size: 1.2em;
            font-weight: 600;
        }

        /* Mask Editor Styles */
        .mask-editor-container {
            margin-top: 20px;
            text-align: center;
        }

        .mask-canvas-wrapper {
            position: relative;
            display: inline-block;
            cursor: crosshair;
        }

        .mask-canvas-wrapper canvas {
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        #maskCanvas {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0.5;
        }

        .mask-tools {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .mask-tools button {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s;
        }

        .mask-tools button:hover {
            background: #f0f2ff;
        }

        .mask-tools button.active {
            background: #667eea;
            color: white;
        }

        .brush-size-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brush-size-container input {
            width: 100px;
        }

        .chat-container {
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .message {
            margin-bottom: 20px;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 80%;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message.ai {
            background: #667eea;
            color: white;
            margin-right: auto;
        }

        .message.user {
            background: #e8ebff;
            color: #333;
            margin-left: auto;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 500;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus,
        .input-group select:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
            margin-right: 10px;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .loading {
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .color-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .color-card {
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s;
            cursor: pointer;
            border: 3px solid transparent;
        }

        .color-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .color-card.selected {
            border: 3px solid #667eea;
        }

        .color-swatch {
            height: 120px;
            position: relative;
        }

        .color-info {
            padding: 20px;
        }

        .color-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .color-code {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .color-description {
            color: #555;
            font-size: 0.95em;
            line-height: 1.5;
            margin-bottom: 15px;
        }

        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .comparison-image {
            text-align: center;
        }

        .comparison-image img {
            width: 100%;
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .comparison-image h4 {
            margin-top: 10px;
            color: #333;
        }

        .progress-bar {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s;
        }

        .step-indicator {
            text-align: center;
            margin-bottom: 20px;
            color: #666;
        }

        .auto-detect-info {
            background: #f0f8ff;
            border: 1px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-size: 0.95em;
            color: #444;
        }

        .auto-detect-info strong {
            color: #667eea;
        }

        @media (max-width: 768px) {
            .comparison-container {
                grid-template-columns: 1fr;
            }
            
            .mask-tools {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® AI Color Consultation</h1>
            <p>Upload your room photo and get personalized Sherwin Williams color recommendations</p>
        </div>

        <div class="content">
            <!-- Step 1: Upload Photo -->
            <div class="step active" id="step1">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì∏</div>
                    <h3>Upload Your Room Photo</h3>
                    <p>Drag and drop or click to select an image</p>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                <div class="preview-container" id="previewContainer" style="display: none;">
                    <div class="preview-wrapper">
                        <img id="uploadedImage" class="preview-image" alt="Room preview">
                        <div class="image-overlay" onclick="replacePhoto()">
                            <div class="overlay-content">
                                <div class="overlay-icon">üîÑ</div>
                                <div class="overlay-text">Click to Replace Photo</div>
                            </div>
                        </div>
                    </div>
                    <br><br>
                    <button class="btn btn-primary" onclick="goToMaskStep()">Continue to Select Walls ‚Üí</button>
                </div>
            </div>

            <!-- Step 1.5: Mask Selection -->
            <div class="step" id="step1b">
                <h2 style="text-align: center; margin-bottom: 20px;">Select the Areas to Paint</h2>
                <p style="text-align: center; color: #666; margin-bottom: 20px;">
                    Paint over the walls/ceiling you want to change color. Don't worry about being perfect!
                </p>
                
                <div class="mask-editor-container">
                    <div class="mask-tools">
                        <button id="brushBtn" class="active" onclick="setTool('brush')">üñåÔ∏è Paint</button>
                        <button id="eraserBtn" onclick="setTool('eraser')">üßπ Erase</button>
                        <button onclick="clearMask()">üóëÔ∏è Clear All</button>
                        <button onclick="autoDetectWalls()">‚ú® Auto-Detect Walls</button>
                        <div class="brush-size-container">
                            <label>Size:</label>
                            <input type="range" id="brushSize" min="5" max="100" value="30" oninput="updateBrushSize()">
                            <span id="brushSizeLabel">30</span>
                        </div>
                    </div>
                    
                    <div class="auto-detect-info">
                        <strong>üí° Tip:</strong> Click "Auto-Detect Walls" to automatically find wall areas, then use the brush to refine. 
                        The preview will apply your chosen paint color only to the areas you select!
                    </div>
                    
                    <div class="mask-canvas-wrapper" id="canvasWrapper">
                        <canvas id="imageCanvas"></canvas>
                        <canvas id="maskCanvas"></canvas>
                    </div>
                </div>
                
                <br>
                <div style="text-align: center;">
                    <button class="btn btn-secondary" onclick="goBackToUpload()">‚Üê Back</button>
                    <button class="btn btn-primary" onclick="startQuestionnaire()">Continue to Questions ‚Üí</button>
                </div>
            </div>

            <!-- Step 2: Questionnaire -->
            <div class="step" id="step2">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
                <div class="chat-container" id="chatContainer"></div>
                <div id="inputArea"></div>
            </div>

            <!-- Step 3: Results -->
            <div class="step" id="step3">
                <h2 style="text-align: center; margin-bottom: 30px;">Your Personalized Sherwin Williams Color Recommendations</h2>
                <div id="recommendations"></div>
                <br>
                <div style="text-align: center;">
                    <button class="btn btn-secondary" onclick="location.reload()">Start Over</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let uploadedImage = null;
        let imageBase64 = null;
        let maskData = null;
        let currentQuestion = 0;
        let answers = {};
        let currentTool = 'brush';
        let brushSize = 30;
        let isDrawing = false;
        let imageCanvas, maskCanvas, imageCtx, maskCtx;
        let canvasWidth, canvasHeight;
        let recommendedColors = [];

        const questions = [
            {
                id: 'surfaces_to_paint',
                question: "What surfaces are you painting?",
                type: 'select',
                options: ['All walls only', 'Walls and ceiling', 'Walls and trim', 'Everything (walls, ceiling, and trim)', 'Just one accent wall']
            },
            {
                id: 'room_type',
                question: "What type of room is this?",
                type: 'select',
                options: ['Living Room', 'Bedroom', 'Kitchen', 'Bathroom', 'Office', 'Dining Room', 'Hallway', 'Other']
            },
            {
                id: 'lighting',
                question: "What kind of natural lighting does this room get?",
                type: 'select',
                options: ['Lots of natural light', 'Moderate natural light', 'Limited natural light', 'No natural light']
            },
            {
                id: 'light_bulbs',
                question: "What type of light bulbs do you typically use?",
                type: 'select',
                options: ['Warm white (yellowish)', 'Cool white (bluish)', 'Daylight (neutral)', 'Not sure']
            },
            {
                id: 'style',
                question: "What style are you going for?",
                type: 'select',
                options: [
                    'Modern/Contemporary - Clean lines, minimal decor',
                    'Traditional - Classic, timeless, elegant',
                    'Minimalist - Simple, uncluttered, functional',
                    'Rustic/Farmhouse - Cozy, natural wood, vintage',
                    'Bohemian - Colorful, eclectic, artistic',
                    'Industrial - Exposed brick, metal, urban loft',
                    'Coastal - Beachy, light, airy, nautical',
                    'Transitional - Blend of traditional and modern'
                ]
            },
            {
                id: 'mood',
                question: "What mood do you want to create in this space?",
                type: 'select',
                options: ['Calm and relaxing', 'Energetic and vibrant', 'Warm and cozy', 'Cool and refreshing', 'Sophisticated and elegant', 'Bright and cheerful']
            },
            {
                id: 'existing_colors',
                question: "What are the dominant colors in your existing furniture and decor?",
                type: 'text',
                placeholder: 'e.g., brown leather couch, white curtains, gray rug'
            },
            {
                id: 'avoid_colors',
                question: "Are there any colors you definitely want to avoid?",
                type: 'text',
                placeholder: 'e.g., no yellows or oranges'
            },
            {
                id: 'preference',
                question: "Do you prefer warm tones, cool tones, or neutral tones?",
                type: 'select',
                options: ['Warm tones (reds, oranges, yellows)', 'Cool tones (blues, greens, purples)', 'Neutral tones (grays, beiges, whites)', 'No preference']
            },
            {
                id: 'additional_info',
                question: "Any other details you'd like to share about your space or color preferences?",
                type: 'textarea',
                placeholder: 'Optional: Tell us anything else that might help...'
            }
        ];

        // ========================
        // Upload Area Handlers
        // ========================
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewContainer = document.getElementById('previewContainer');

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            handleFile(file);
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            handleFile(file);
            fileInput.value = '';
        });

        function handleFile(file) {
            if (file && file.type.startsWith('image/')) {
                uploadedImage = file;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = function() {
                        // Resize if too large (max 1200px)
                        let width = img.width;
                        let height = img.height;
                        const maxSize = 1200;
                        
                        if (width > maxSize || height > maxSize) {
                            if (width > height) {
                                height = Math.round(height * maxSize / width);
                                width = maxSize;
                            } else {
                                width = Math.round(width * maxSize / height);
                                height = maxSize;
                            }
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        imageBase64 = canvas.toDataURL('image/png');
                        document.getElementById('uploadedImage').src = imageBase64;
                        uploadArea.style.display = 'none';
                        previewContainer.style.display = 'block';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function replacePhoto() {
            uploadedImage = null;
            imageBase64 = null;
            previewContainer.style.display = 'none';
            uploadArea.style.display = 'block';
            fileInput.value = '';
        }

        // ========================
        // Mask Editor Functions
        // ========================
        function goToMaskStep() {
            document.getElementById('step1').classList.remove('active');
            document.getElementById('step1b').classList.add('active');
            initMaskEditor();
        }

        function goBackToUpload() {
            document.getElementById('step1b').classList.remove('active');
            document.getElementById('step1').classList.add('active');
        }

        function initMaskEditor() {
            imageCanvas = document.getElementById('imageCanvas');
            maskCanvas = document.getElementById('maskCanvas');
            imageCtx = imageCanvas.getContext('2d');
            maskCtx = maskCanvas.getContext('2d');

            const img = new Image();
            img.onload = function() {
                // Calculate display size (max 700px wide for UI)
                let displayWidth = img.width;
                let displayHeight = img.height;
                const maxDisplayWidth = 700;
                
                if (displayWidth > maxDisplayWidth) {
                    displayHeight = Math.round(displayHeight * maxDisplayWidth / displayWidth);
                    displayWidth = maxDisplayWidth;
                }
                
                canvasWidth = displayWidth;
                canvasHeight = displayHeight;
                
                imageCanvas.width = displayWidth;
                imageCanvas.height = displayHeight;
                maskCanvas.width = displayWidth;
                maskCanvas.height = displayHeight;
                
                imageCtx.drawImage(img, 0, 0, displayWidth, displayHeight);
                
                // Clear mask
                maskCtx.clearRect(0, 0, displayWidth, displayHeight);
            };
            img.src = imageBase64;

            // Mouse events
            maskCanvas.addEventListener('mousedown', startDrawing);
            maskCanvas.addEventListener('mousemove', draw);
            maskCanvas.addEventListener('mouseup', stopDrawing);
            maskCanvas.addEventListener('mouseout', stopDrawing);

            // Touch events
            maskCanvas.addEventListener('touchstart', handleTouch);
            maskCanvas.addEventListener('touchmove', handleTouchMove);
            maskCanvas.addEventListener('touchend', stopDrawing);
        }

        function startDrawing(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing) return;
            
            const rect = maskCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            maskCtx.beginPath();
            maskCtx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
            
            if (currentTool === 'brush') {
                maskCtx.fillStyle = 'rgba(102, 126, 234, 0.7)';
                maskCtx.fill();
            } else {
                maskCtx.globalCompositeOperation = 'destination-out';
                maskCtx.fill();
                maskCtx.globalCompositeOperation = 'source-over';
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrawing(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            draw(mouseEvent);
        }

        function stopDrawing() {
            isDrawing = false;
        }

        function setTool(tool) {
            currentTool = tool;
            document.getElementById('brushBtn').classList.toggle('active', tool === 'brush');
            document.getElementById('eraserBtn').classList.toggle('active', tool === 'eraser');
        }

        function updateBrushSize() {
            brushSize = document.getElementById('brushSize').value;
            document.getElementById('brushSizeLabel').textContent = brushSize;
        }

        function clearMask() {
            maskCtx.clearRect(0, 0, canvasWidth, canvasHeight);
        }

        function autoDetectWalls() {
            // Get image data
            const imgData = imageCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            const data = imgData.data;
            
            // Clear current mask
            maskCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Create mask for wall-like areas
            const maskImageData = maskCtx.createImageData(canvasWidth, canvasHeight);
            const maskPixels = maskImageData.data;
            
            // Analyze image for large uniform areas (likely walls)
            for (let y = 0; y < canvasHeight; y++) {
                for (let x = 0; x < canvasWidth; x++) {
                    const i = (y * canvasWidth + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Calculate various properties
                    const brightness = (r + g + b) / 3;
                    const saturation = Math.max(r, g, b) - Math.min(r, g, b);
                    
                    // Check local uniformity (compare with neighbors)
                    let isUniform = true;
                    const checkRadius = 3;
                    let diffSum = 0;
                    let checkCount = 0;
                    
                    for (let dy = -checkRadius; dy <= checkRadius; dy++) {
                        for (let dx = -checkRadius; dx <= checkRadius; dx++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < canvasWidth && ny >= 0 && ny < canvasHeight) {
                                const ni = (ny * canvasWidth + nx) * 4;
                                const nr = data[ni];
                                const ng = data[ni + 1];
                                const nb = data[ni + 2];
                                diffSum += Math.abs(r - nr) + Math.abs(g - ng) + Math.abs(b - nb);
                                checkCount++;
                            }
                        }
                    }
                    
                    const avgDiff = diffSum / checkCount;
                    
                    // Wall detection heuristics:
                    // - Relatively uniform areas (low local variance)
                    // - Not too dark (not shadows or dark furniture)
                    // - Low to medium saturation (walls usually aren't super colorful)
                    const isWallLike = avgDiff < 30 && brightness > 80 && brightness < 250 && saturation < 150;
                    
                    if (isWallLike) {
                        maskPixels[i] = 102;     // R
                        maskPixels[i + 1] = 126; // G
                        maskPixels[i + 2] = 234; // B
                        maskPixels[i + 3] = 180; // A
                    }
                }
            }
            
            maskCtx.putImageData(maskImageData, 0, 0);
            
            // Apply some smoothing with morphological operations (dilate then erode)
            smoothMask();
        }

        function smoothMask() {
            // Simple smoothing: get mask, apply blur-like effect
            const maskData = maskCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            const smoothed = new Uint8ClampedArray(maskData.data);
            
            // Dilate
            for (let y = 1; y < canvasHeight - 1; y++) {
                for (let x = 1; x < canvasWidth - 1; x++) {
                    const i = (y * canvasWidth + x) * 4;
                    let maxAlpha = maskData.data[i + 3];
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const ni = ((y + dy) * canvasWidth + (x + dx)) * 4;
                            maxAlpha = Math.max(maxAlpha, maskData.data[ni + 3]);
                        }
                    }
                    
                    if (maxAlpha > 100) {
                        smoothed[i] = 102;
                        smoothed[i + 1] = 126;
                        smoothed[i + 2] = 234;
                        smoothed[i + 3] = 180;
                    }
                }
            }
            
            const newImageData = new ImageData(smoothed, canvasWidth, canvasHeight);
            maskCtx.putImageData(newImageData, 0, 0);
        }

        function getMaskData() {
            // Get the mask as binary data
            const maskImageData = maskCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            return maskImageData;
        }

        // ========================
        // Questionnaire Functions
        // ========================
        function startQuestionnaire() {
            // Save mask data
            maskData = getMaskData();
            
            document.getElementById('step1b').classList.remove('active');
            document.getElementById('step2').classList.add('active');
            askQuestion();
        }

        function askQuestion() {
            const question = questions[currentQuestion];
            const chatContainer = document.getElementById('chatContainer');
            const inputArea = document.getElementById('inputArea');
            
            const progress = ((currentQuestion + 1) / questions.length) * 100;
            document.getElementById('progressFill').style.width = progress + '%';

            const aiMessage = document.createElement('div');
            aiMessage.className = 'message ai';
            aiMessage.textContent = question.question;
            chatContainer.appendChild(aiMessage);

            let inputHTML = '';
            if (question.type === 'select') {
                inputHTML = `
                    <div class="input-group">
                        <select id="currentAnswer" class="answer-input">
                            <option value="">Select an option...</option>
                            ${question.options.map(opt => `<option value="${opt}">${opt}</option>`).join('')}
                        </select>
                    </div>
                `;
            } else if (question.type === 'textarea') {
                inputHTML = `
                    <div class="input-group">
                        <textarea id="currentAnswer" class="answer-input" rows="3" placeholder="${question.placeholder || ''}"></textarea>
                    </div>
                `;
            } else {
                inputHTML = `
                    <div class="input-group">
                        <input type="text" id="currentAnswer" class="answer-input" placeholder="${question.placeholder || ''}">
                    </div>
                `;
            }

            inputHTML += `<button class="btn btn-primary" onclick="submitAnswer()">Next ‚Üí</button>`;
            inputArea.innerHTML = inputHTML;

            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function submitAnswer() {
            const answerInput = document.getElementById('currentAnswer');
            const answer = answerInput.value.trim();

            if (!answer && currentQuestion < questions.length - 1) {
                alert('Please provide an answer before continuing');
                return;
            }

            const question = questions[currentQuestion];
            answers[question.id] = answer;

            if (answer) {
                const chatContainer = document.getElementById('chatContainer');
                const userMessage = document.createElement('div');
                userMessage.className = 'message user';
                userMessage.textContent = answer;
                chatContainer.appendChild(userMessage);
            }

            currentQuestion++;

            if (currentQuestion < questions.length) {
                setTimeout(askQuestion, 300);
            } else {
                generateRecommendations();
            }
        }

        // ========================
        // Color Recommendations
        // ========================
        async function generateRecommendations() {
            const inputArea = document.getElementById('inputArea');
            inputArea.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Analyzing your space and generating personalized color recommendations...</p>
                </div>
            `;

            try {
                const apiUrl = window.location.origin + '/api/generate-colors';
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        answers: answers
                    })
                });

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('Non-JSON response:', text);
                    throw new Error('Server returned invalid response. Check that API keys are set correctly in Vercel environment variables.');
                }

                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                recommendedColors = data.colors;
                
                inputArea.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Creating color previews for your room...</p>
                    </div>
                `;

                // Generate previews for each color
                await generateColorPreviews(recommendedColors);
                
            } catch (error) {
                console.error('Error in generateRecommendations:', error);
                inputArea.innerHTML = `
                    <div style="text-align: center; color: red; padding: 20px;">
                        <p><strong>Error:</strong> ${error.message}</p>
                        <br>
                        <p style="font-size: 0.9em;">Common fixes:</p>
                        <ul style="text-align: left; display: inline-block; font-size: 0.9em;">
                            <li>Check that ANTHROPIC_API_KEY is added in Vercel Settings ‚Üí Environment Variables</li>
                            <li>Make sure you selected "Production" when adding keys</li>
                            <li>Try redeploying from the Deployments tab</li>
                        </ul>
                        <br><br>
                        <button class="btn btn-primary" onclick="generateRecommendations()">Retry</button>
                    </div>
                `;
            }
        }

        async function generateColorPreviews(colors) {
            // Generate preview for each color using client-side processing
            const colorsWithPreviews = colors.map(color => {
                const previewImage = applyColorToMaskedArea(color.hex);
                return {
                    ...color,
                    imageUrl: previewImage
                };
            });
            
            displayResults(colorsWithPreviews);
        }

        function applyColorToMaskedArea(hexColor) {
            // Create a canvas for the result
            const resultCanvas = document.createElement('canvas');
            resultCanvas.width = canvasWidth;
            resultCanvas.height = canvasHeight;
            const resultCtx = resultCanvas.getContext('2d');
            
            // Get original image data
            const originalData = imageCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            const pixels = new Uint8ClampedArray(originalData.data);
            
            // Parse target color
            const hex = hexColor.replace('#', '');
            const targetR = parseInt(hex.substr(0, 2), 16);
            const targetG = parseInt(hex.substr(2, 2), 16);
            const targetB = parseInt(hex.substr(4, 2), 16);
            
            // Apply color to masked areas while preserving lighting
            for (let i = 0; i < pixels.length; i += 4) {
                const maskAlpha = maskData.data[i + 3];
                
                if (maskAlpha > 50) {
                    const r = pixels[i];
                    const g = pixels[i + 1];
                    const b = pixels[i + 2];
                    
                    // Calculate luminance (perceived brightness)
                    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                    
                    // Apply color while preserving luminance
                    // This keeps shadows and highlights realistic
                    const blendFactor = maskAlpha / 255 * 0.85;
                    
                    // Adjust target color by luminance to preserve lighting
                    const adjustedR = targetR * luminance;
                    const adjustedG = targetG * luminance;
                    const adjustedB = targetB * luminance;
                    
                    // Blend original with colored version
                    pixels[i] = Math.round(r * (1 - blendFactor) + adjustedR * blendFactor);
                    pixels[i + 1] = Math.round(g * (1 - blendFactor) + adjustedG * blendFactor);
                    pixels[i + 2] = Math.round(b * (1 - blendFactor) + adjustedB * blendFactor);
                }
            }
            
            // Put the modified pixels back
            const resultImageData = new ImageData(pixels, canvasWidth, canvasHeight);
            resultCtx.putImageData(resultImageData, 0, 0);
            
            return resultCanvas.toDataURL('image/png');
        }

        function displayResults(colors) {
            document.getElementById('step2').classList.remove('active');
            document.getElementById('step3').classList.add('active');
            
            const recommendationsDiv = document.getElementById('recommendations');
            let html = `
                <div class="comparison-container">
                    <div class="comparison-image">
                        <h4>Original Photo</h4>
                        <img src="${imageBase64}" alt="Original room">
                    </div>
                    <div class="comparison-image">
                        <h4>Preview (Click a color below)</h4>
                        <img id="previewImage" src="${colors[0]?.imageUrl || imageBase64}" alt="Preview">
                    </div>
                </div>
                
                <h3 style="text-align: center; margin-bottom: 20px;">Your Color Recommendations:</h3>
                <div class="color-results" id="colorCards">
            `;
            
            colors.forEach((color, index) => {
                html += `
                    <div class="color-card ${index === 0 ? 'selected' : ''}" data-index="${index}" onclick="selectColor(${index})">
                        <div class="color-swatch" style="background: ${color.hex}"></div>
                        <div class="color-info">
                            <div class="color-name">${color.name}</div>
                            <div class="color-code">${color.hex}</div>
                            <div class="color-description">${color.description}</div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            recommendationsDiv.innerHTML = html;
            
            // Store colors globally for selection
            window.displayedColors = colors;
        }

        function selectColor(index) {
            const color = window.displayedColors[index];
            
            // Update preview image
            const previewImg = document.getElementById('previewImage');
            if (previewImg && color.imageUrl) {
                previewImg.style.opacity = '0.5';
                previewImg.onload = () => {
                    previewImg.style.opacity = '1';
                };
                previewImg.src = color.imageUrl;
            }
            
            // Update selected state
            document.querySelectorAll('.color-card').forEach((card, i) => {
                card.classList.toggle('selected', i === index);
            });
        }
    </script>
</body>
</html>
